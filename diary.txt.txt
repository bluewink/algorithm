# 21.05.15
10971번
연결 비용을 최소화 하라기에 MST를 생각했다.
하지만 N이 10밖에 되지 않기 때문에 Bactracking으로 풀 수 있다!

# 21.05.17
14938번
모든 점에서의 최단 거리를 구해야 하고, n=100이라서 플로이드-와샬을 이용했다.
플로이드-와샬 구현할 때 loop variable의 순서를 잘못 해서 30분을 헤맸다...
k,i,j 에서 k가 중간에 거쳐가야 할 vertex, i->j 가 이동 경로다!

# 21.05.22
15486번
DP는 너무 어렵다... 이전에 한번 풀어본 문제임에도 점화식을 세울 수가 없었다.
조금 더 고민해보자

# 21.05.27
3055번
물이 한 군데도 없을 수 있다... 문제를 잘 읽자

# 21.06.18
11779번
다익스트라에서 이동 경로를 구하려면.. from[ ] 배열을 하나 두면 된다.
모든 점을 한번씩만 방문하기 때문에!

# 21.06.21
1525번
방문 체크를 이런 식으로 해도 되나..? 했던게 풀려서 기분이 좋다.
vs에서는 무한 루프를 돌던 게 boj에서는 ac를 받았다. debug 모드 - release 모드 수행 속도 차이가 있다고 한다.

# 21.06.22
5427번
상근이가 움직이는 것을 방문 체크하지 않아서 메모리 초과가 났다.
그리고 board를 초기화해야 한다. 범위 밖이 사용되고 있기 때문이다.

#21.06.23
14442번
벽을 부순 횟수를 큐에 함께 저장해야, 각 칸에서 벽을 부술 수 있는지를 판단할 수 있다.
방문 체크하는 부분에 오타가 있어서 시간초과가 났다. 다음에 방문할 곳을 체크해야 했다.

#21.06.24
6593번
TESTCASE가 여러 개인 BFS를 풀 때 Queue를 초기화하지 않아서 두 번 틀렸다.

#21.06.25
16946번
벽부수고 이동하기4 brute force말고는 다른 방법이 떠오르지 않는다.. 어떻게 시간초과를 피할 수 있을까???

#21.06.26
2953번
파이썬으로 풀기 시작했다. 짠 코드가 pythonic하지 않아서 다른 사람의 코드를 참고했다.
입력을 받을 때 map에 sum()을 씌우면 합계를 바로 구할 수 있어서 코드 길이가 줄어든다.

#21.06.27
1175번
방문체크해줄 방법이 도저히 생각나지 않아서 풀이를 보았다...
visited[첫번째 장소 방문 여부][두번째 장소 방문 여부][direction][row][col] : 5차원 배열로 방문체크를 할 수 있다.

#21.06.29
1039번
백트래킹으로 풀어보려 했으나 방문체크가 제대로 되지 않는다. BFS로 풀 수 있다고 하니 다시 도전해보자.

#21.06.30
1107번
target이 0~500000 까지 주어지지만 더 큰 수에서 감소하는 케이스가 있으므로 채널 수를 최대 1000000까지는 생각해야한다.
중복 방문이 허용되는 경우가 있다. 그래서 1) +,-로 접근할 때 2) 숫자 버튼으로 접근할 때. 이렇게 visited를 2차원으로 설정했다.

#21.07.01
2225번
DP인 것까지는 알았지만 점화식을 세우는데 실패했다. 풀이를 보니, 2차원 table을 만들면 점화식 도출이 쉬워진다.
점화식이 잘 그려지지 않는다면 table을 만들어볼 수 있겠다.

#21.07.02
1915번
브루트포스로 하면 시간초과가 나는데.. 시간을 줄일 방법이 전혀 떠오르지 않았다. 풀이를 보니 DP로 풀 수 있다고 한다...
점화식이 신기하다. DP인걸 알았더라도 풀지 못했을 듯... 익혀놓고 다음에 다시 풀어보자.